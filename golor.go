// -*- coding: utf-8 -*-
// golor.go
// -----------------------------------------------------------------------------
//
// Started on <vie 29-09-2023 22:38:25.455020113 (1696019905)>
// Carlos Linares LÃ³pez <carlos.linares@uc3m.es>
//

// golor provides means for showing text on the standard output with different
// selections of color for both the background and the foreground, and also
// other effects. It is intended to ease usage
//
// It provides the same interface than the Printf family functions, i.e., it
// substitutes all verbs appearing in a string with the given arguments. In
// addition, it provides a new verb, %C{...}:
//
//   - The argument given to %C{...} has to be a color specification.
//
//   - The ellipsis stands for any text which might also contain other verbs to be
//     substituted. Currently, color verbs can not be nested and thus the text
//     enclosed in a color verb can not contain %C{...}
//
// The following discussions are exemplified only with golor.Printf but they
// work in the same way with either golor.Sprintf or golor.Fprintf. The output
// generated by golor.Fprintf is correctly rendered from the shell with commands
// such as cat, less, more, and even bat.
//
// The following example shows how to write a sentence wtih two words, where
// only the foreground colors and its properties (using the bitwise or operator)
// have been set. The first word is shown in red and bold, whereas the second
// appears in blue and underlined.
//
//	golor.Printf("%C{Hello} %C{World}\n", uint32(0xff0000)|golor.BOLD32, uint32(0x00ff00)|golor.UNDERLINE32)
//
// It is also possible to set both the foreground and background colors along
// with its properties using uint64 as shown below. In this case, the
// combination RGB of the background color has to be given before the foreground
// color and the properties are set using the bitwise operator
//
//	golor.Printf("%C{Hello} %C{World}\n", uint64(0xaadd44ff0000)|golor.BOLD64, uint64(0x43207200ff00)|golor.UNDERLINE64)
//
// In case it is required, it is also possible to verbosely set a foreground
// and/or a background along with a combination of properties using values of
// the types [Effect], [FgEffect] and [BgEffect]
//
//	effect := golor.Effect{
//	    Fg:         golor.Color{R: 0xff, G: 0x00, B: 0xff},
//	    Properties: golor.ITALIC}
//	golor.Printf("Happy %C{%v}!\n", effect, "coloring")
//
// which shows the word "coloring" in pink with a black background
//
// Note that %C{...} also allows using any other verbs, e.g.:
//
//	golor.Printf("Happy %C{%+v}!\n", effect, effect)
//
// which shows the contents of the definition of the variable effect defined
// above in pink
//
// See the [README.md] file for more information
//
// [README.md]: https://github.com/clinaresl/golor/blob/main/README.md
package golor

import (
	"fmt"
	"io"
	"regexp"
)

// Constants
// ----------------------------------------------------------------------------

// The following constants define the different components of the ASCII escape
// codes used for showing properties
const (
	prefix             = "\033["
	foreground_prefix  = "38;2"
	background_prefix  = "48;2"
	bold_prefix        = "1"
	dim_prefix         = "2"
	italic_prefix      = "3"
	underline_prefix   = "4"
	slow_blink_prefix  = "5"
	rapid_blink_prefix = "6"
	crossed_out_prefix = "9"
	suffix             = "\033[0m"
)

// Constants used to filter the red, green and blue colors of the foreground and
// background colors when using either uint32 or uint64 types
const (

	// Specification with uin32
	properties32 = 0xff000000
	fg_red32     = 0xff0000
	fg_green32   = 0x00ff00
	fg_blue32    = 0x0000ff

	// Specification with uin64
	properties64 = 0x00ff000000000000
	bg_red64     = 0xff0000000000
	bg_green64   = 0x00ff00000000
	bg_blue64    = 0x0000ff000000
)

// The following constants can be used for defining properties with the types
// [Effect], [FgEffect] and [BgEffect]
const (
	BOLD = 1 << (iota + 0)
	DIM
	ITALIC
	UNDERLINE
	SLOW_BLINK
	RAPID_BLINK
	CROSSED_OUT
)

// The following constants must be used for defining properties with the type
// [Effect32]
const (
	BOLD32 = 1 << (iota + 24)
	DIM32
	ITALIC32
	UNDERLINE32
	SLOW_BLINK32
	RAPID_BLINK32
	CROSSED_OUT32
)

// The following constants must be used for defining properties with the type
// [Effect64]
const (
	BOLD64 = 1 << (iota + 48)
	DIM64
	ITALIC64
	UNDERLINE64
	SLOW_BLINK64
	RAPID_BLINK64
	CROSSED_OUT64
)

// Provide a map between properties and their sequence
var propertyPrefix = map[uint8]string{
	BOLD:        bold_prefix,
	DIM:         dim_prefix,
	ITALIC:      italic_prefix,
	UNDERLINE:   underline_prefix,
	SLOW_BLINK:  slow_blink_prefix,
	RAPID_BLINK: rapid_blink_prefix,
	CROSSED_OUT: crossed_out_prefix,
}

// The following regular expression is used for matching any verb, thouse used
// in the fmt Printf family function, and also the verb %C{...}
const all_verbs_regexp = `%(C\{([^\}]+)\}|(?<flags>[-+#0 ])?(?<width>\d+|\*)?(?:\.(?<precision>\d+|\*))?(?<length>[hljztL]|hh|ll)?(?<specifier>[diuoxXfFeEgGaAcspnTv]))`

// The following regular expression is used instead for matching color codes
// only %C{...}
const color_regexp = `^%C\{([^\}]+)\}`

// Types
// ----------------------------------------------------------------------------

// The following type defines an RGB color to be used only with type [Effect]
type Color struct {
	R, G, B uint8
}

// The following type defines a combination of foreground, background colors and
// properties. Note that both the foreground and background colors have to be of
// type [Color]
type Effect struct {
	Fg, Bg     Color
	Properties uint8
}

// The following type defines a combination of foreground color and properties.
// The foregrround color must be given with three different bytes
type FgEffect struct {
	R, G, B    uint8
	Properties uint8
}

// The following type defines a combination of background color and properties.
// The backgrround color must be given with three different bytes
type BgEffect struct {
	R, G, B    uint8
	Properties uint8
}

// It is also possible to define just the foreground color and the properties
// using an uint32
type Effect32 = uint32

// It is also possible to define the background and foreground colors (in that
// order) and the properties using an uint64
type Effect64 = uint64

// Variables
// ----------------------------------------------------------------------------

// (Must)Compiled regexps
var allVerbs = regexp.MustCompile(all_verbs_regexp)
var colorVerb = regexp.MustCompile(color_regexp)

// Functions
// ----------------------------------------------------------------------------

// Process the specified color specification and return a string representing
// the foreground color. It returns an error in case the specification is given
// in an unknown format
func processForegroundColor(arg any) (output string, err error) {

	// This package supports various formats for specifying colors
	switch val := arg.(type) {

	case Effect:

		output = fmt.Sprintf("%v;%v;%v", val.Fg.R, val.Fg.G, val.Fg.B)

	case FgEffect:

		output = fmt.Sprintf("%v;%v;%v", val.R, val.G, val.B)

	case BgEffect:

		// This type does not provide information about the foreground color
		break

	case Effect32:

		output = fmt.Sprintf("%v;%v;%v", (val&fg_red32)>>16, (val&fg_green32)>>8, val&fg_blue32)

	case Effect64:

		output = fmt.Sprintf("%v;%v;%v", (val&fg_red32)>>16, (val&fg_green32)>>8, val&fg_blue32)

	default:
		return "", fmt.Errorf("Unsuported foreground color format: %v\n", arg)
	}

	return
}

// Process the specified color specification and return a string representing
// the background color. It returns an error in case the specification is given
// in an unknown format
func processBackgroundColor(arg any) (output string, err error) {

	// This package supports various formats for specifying colors
	switch val := arg.(type) {

	case Effect:

		output = fmt.Sprintf("%v;%v;%v", val.Bg.R, val.Bg.G, val.Bg.B)

	case FgEffect:

		// This type does not provide information about the background color
		break

	case BgEffect:

		output = fmt.Sprintf("%v;%v;%v", val.R, val.G, val.B)

	case Effect32:

		// This type does not provide information about the background color
		break

	case Effect64:

		output = fmt.Sprintf("%v;%v;%v", (val&bg_red64)>>40, (val&bg_green64)>>32, val&bg_blue64>>24)

	default:
		return "", fmt.Errorf("Unsuported background color format: %v\n", arg)
	}

	return
}

// Process the specified properties and return the string with its ANSI codes
func processProperties(properties uint8) (output string) {

	// Process all properties one by one
	var idx uint8
	for idx = BOLD; idx <= CROSSED_OUT; idx <<= 1 {

		if properties&idx != 0 {
			output += fmt.Sprintf(";%v", propertyPrefix[idx])
		}
	}

	return
}

// Given a string chunk, return it preceded by the color prefix corresponding to
// the given argument and ended with the corresponding suffix
func substituteColorVerb(chunk string, arg any) (output string, err error) {

	// This package supports various formats for specifying colors and
	// properties
	switch val := arg.(type) {

	case Effect:

		// Get the foreground and background specs
		fg, fgerr := processForegroundColor(val)
		bg, bgerr := processBackgroundColor(val)
		if fgerr != nil {
			return "", err
		}
		if bgerr != nil {
			return "", err
		}

		output = fmt.Sprintf(`%v%v;%v;%v;%v%vm%v%v`, prefix, foreground_prefix, fg, background_prefix, bg, processProperties(val.Properties), chunk, suffix)

	case FgEffect:

		// Get the foreground spec
		fg, fgerr := processForegroundColor(val)
		if fgerr != nil {
			return "", err
		}

		output = fmt.Sprintf(`%v%v;%v%vm%v%v`, prefix, foreground_prefix, fg, processProperties(val.Properties), chunk, suffix)

	case BgEffect:

		// Get the background specs
		bg, bgerr := processBackgroundColor(val)
		if bgerr != nil {
			return "", err
		}

		output = fmt.Sprintf(`%v%v;%v%vm%v%v`, prefix, background_prefix, bg, processProperties(val.Properties), chunk, suffix)

	case Effect32:

		// Get the foreground spec
		fg, fgerr := processForegroundColor(val)
		if fgerr != nil {
			return "", err
		}

		output = fmt.Sprintf(`%v%v;%v%vm%v%v`, prefix, foreground_prefix, fg, processProperties(uint8((val&properties32)>>24)), chunk, suffix)

	case Effect64:

		// Get the foreground and background specs
		fg, fgerr := processForegroundColor(val)
		bg, bgerr := processBackgroundColor(val)
		if fgerr != nil {
			return "", err
		}
		if bgerr != nil {
			return "", err
		}

		output = fmt.Sprintf(`%v%v;%v;%v;%v%vm%v%v`, prefix, foreground_prefix, fg, background_prefix, bg, processProperties(uint8(val&properties64>>48)), chunk, suffix)

	default:
		return "", fmt.Errorf("Unsupported format: %v\n", arg)
	}

	return
}

// substitute all occurrences of color verbs by their corresponding prefixes and
// suffixes without affecting the other verbs in the format string. It returns:
//
//  1. The resulting string with all color verbs properly substituted,
//
//  2. The list of arguments to be used in the substitution of the remaining verbs,
//
//  3. The number of arguments consumed in the substitution of non-color verbs.
//
//  4. An error in case any is found.
func processColorVerbs(format string, a ...any) (output string, args []any, nargs int, err error) {

	// Keep a counter over the arguments given in a to know which ones to use
	// for substituting the color verbs, and which to use in the substitutions
	// performed by the Printf family
	var idx int

	// An offset is needed to know the position from which the last chunk of
	// format was copied
	var offset int

	// Get the location of all verbs and process them all
	matches := allVerbs.FindAllStringSubmatchIndex(format, -1)
	for _, match := range matches {

		// Check whether this is a color verb
		if colorVerb.MatchString(format[match[0]:match[1]]) {

			// First, process the contents of the color verb. Notice that all
			// the remaining args are used, but the first one which must be used
			// later for substituting the color verb
			contents, cargs, cnargs, cerr := processColorVerbs(format[match[0]+3:match[1]-1], a[idx+1:]...)
			if cerr != nil {
				return "", nil, 0, err
			}

			// copy from the previous offset until the end of the color verb,
			// substitute it, and update the offset
			if chunk, err := substituteColorVerb(contents, a[idx]); err == nil {
				output += format[offset:match[0]]
				output += chunk
				offset = match[1]
			} else {
				return "", nil, 0, err
			}

			// Copy all the necessary args to make the necessary substitutions
			// later inside the color-verb
			for i := 0; i < cnargs; i++ {

				// In fact, these are given by the result of the recursive
				// invocation of ProcessColorVerbs, but not all of them have to
				// be copied, only those consumed in the last processing
				args = append(args, cargs[i])
			}

			// and update the counter of the next arguments to used. Again, note
			// we add 1 to avoid re-using the argument of the color verb
			idx += 1 + cnargs
		} else {

			// Otherwise, copy all elements in the output and update the offset
			output += format[offset:match[1]]
			offset = match[1]

			// and preserve this argument to be used a posteriori
			nargs++
			args = append(args, a[idx])

			// and update the counter of the next argument to use.
			idx++
		}
	}

	// Finally, add to the output string the rest of it since the last offset,
	// and also any other argument that have not been used (this is relevant
	// when procesing nested chunks of the original string)
	output += format[offset:]
	if len(a) > idx {
		args = append(args, a[idx:]...)
	}

	return
}

// golor.Printf is the counterpart of fmt.Printf. It just substitutes the color
// verbs (%C{...}) and queries fmt.Printf to substitute the rest. It returns the
// number of bytes written and any write error encountered.
func Printf(format string, a ...any) (n int, err error) {

	// First, substitute all the color verbs
	cformat, cargs, _, cerr := processColorVerbs(format, a...)
	if cerr != nil {
		return 0, err
	}

	// Let fmt.Printf do the rest of the job
	return fmt.Printf(cformat, cargs...)
}

// golor.Printf is the counterpart of fmt.Sprintf. It just substitutes the color
// verbs (%C{...}) and queries fmt.Sprintf to substitute the rest. It returns the
// resulting string
func Sprintf(format string, a ...any) string {

	// First, substitute all the color verbs
	cformat, cargs, _, cerr := processColorVerbs(format, a...)
	if cerr != nil {
		return ""
	}

	// Let fmt.Sprintf do the rest of the job
	return fmt.Sprintf(cformat, cargs...)
}

// golor.Fprintf is the counterpart of fmt.Fprintf. It just substitutes the
// color verbs (%C{...}) and queries fmt.Fprintf to substitute the rest and to
// write them in the given writer. It returns the number of bytes written and
// any write error encountered.
//
// It panics if the first argument after the writer is not a string
func Fprintf(w io.Writer, a ...any) (n int, err error) {

	// First, substitute all the color verbs. Note that the function panics if
	// the first argument after the writer is not a string
	cformat, cargs, _, cerr := processColorVerbs(a[0].(string), a[1:]...)
	if cerr != nil {
		return 0, err
	}

	// Let fmt.Fprintf do the rest of the job
	return fmt.Fprintf(w, cformat, cargs...)
}

// Local Variables:
// mode:go
// fill-column:80
// End:
